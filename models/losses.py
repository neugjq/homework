import torch
import torch.nn as nn
import torch.nn.functional as F

class YOLOLoss(nn.Module):
    def __init__(self, num_classes, anchors, img_size=640, lambda_coord=5.0, lambda_noobj=0.5):
        super(YOLOLoss, self).__init__()
        self.num_classes = num_classes
        self.anchors = anchors  # È¢ÑÂÆö‰πâÁöÑ anchor boxes, e.g. [[(w,h),...], [...], [...]]
        self.num_anchors = len(anchors[0])
        self.img_size = img_size
        self.lambda_coord = lambda_coord
        self.lambda_noobj = lambda_noobj

        # loss ÂáΩÊï∞ÈÉΩËÆæ‰∏∫ noneÔºåÂêéÈù¢ÊâãÂä®Âä†ÊùÉ„ÄÅmask
        self.mse_loss = nn.MSELoss(reduction='none')
        self.bce_loss = nn.BCEWithLogitsLoss(reduction='none')
        self.ce_loss  = nn.CrossEntropyLoss(reduction='none')
    # def forward(self, predictions, targets):
    #     """
    #     predictions: Ê®°ÂûãËæìÂá∫ÂàóË°® [small, medium, large]  Ôºàlen = SÔºâ
    #     targets:     ÁúüÂÆûÊ†áÁ≠æÂàóË°®ÔºåË¶Å‰πàÊåâÂ∞∫Â∫¶Ôºàlen=SÔºâÔºåË¶Å‰πàÊåâÊ†∑Êú¨Ôºàlen=BÔºâ
    #     """
    #     # ‚Äî‚Äî 1. Â¶ÇÊûú targets ÊòØÊåâÊ†∑Êú¨Ôºàlen=BÔºâ‰º†ËøõÊù•ÁöÑÔºåÂ∞±ÊääÂÆÉËΩ¨ÊàêÊåâÂ∞∫Â∫¶Ôºàlen=SÔºâ
    #     if len(targets) != len(predictions):
    #         # ÂÅáËÆæÊØè‰∏™ targets[i] ÈÉΩÊòØ‰∏™ dictÔºådict ÈáåÁöÑÊØè‰∏™ value
    #         # ÈÉΩÊòØ‰∏Ä‰∏™ÂèØ‰ª•ÈÄöËøá [scale_index] Á¥¢ÂºïÁöÑÂº†ÈáèÊàñ list„ÄÇ
    #         B = len(targets)
    #         S = len(predictions)
    #         new_targets = []
    #         for s in range(S):
    #             ts = {}
    #             for k in targets[0].keys():
    #                 # Êî∂ÈõÜ batch ÈáåÊØè‰∏™Ê†∑Êú¨ÁöÑÁ¨¨ s ‰∏™Â∞∫Â∫¶ÈÉ®ÂàÜÔºåÁÑ∂Âêé stack
    #                 vals = [t[k][s] for t in targets]                # list of tensors
    #                 ts[k] = torch.stack(vals, dim=0).to(predictions[s].device)
    #             new_targets.append(ts)
    #         targets = new_targets

    #     total_loss = 0
    #     loss_dict = {'coord_loss': 0, 'obj_loss': 0, 'noobj_loss': 0, 'cls_loss': 0}

    #     # ‚Äî‚Äî 2. ‰∏ªÂæ™ÁéØ
    #     for i, pred in enumerate(predictions):
    #         target = {k: v.to(pred.device) for k, v in targets[i].items()}
    #         tgt_boxes = target['boxes']
    #         tgt_obj   = target['conf']
    #         tgt_cls   = target['classes']
    #         tgt_mask  = target['mask']

    #         # ‚Äî‚Äî 2.1 Ë∞ÉËØï‰ø°ÊÅØ
    #         print(f"\nScale {i}:")
    #         print(f"pred shape: {pred.shape}")
    #         print(f"tgt_boxes shape: {tgt_boxes.shape}")
    #         print(f"tgt_mask shape: {tgt_mask.shape}")

    #         # ‚Äî‚Äî 2.2 Êï¥ÂΩ¢È¢ÑÊµã
    #         batch_size, H, W = pred.shape[0], pred.shape[1], pred.shape[2]
    #         if pred.dim() == 4:
    #             pred = pred.view(batch_size, H, W, self.num_anchors, -1)
    #         pred_boxes = pred[..., :4]     # [B, H, W, A, 4]
    #         pred_obj   = pred[..., 4]      # [B, H, W, A]
    #         pred_cls   = pred[..., 5:]     # [B, H, W, A, C]

    #         # ‚Äî‚Äî 2.3 ÂØπÈΩê tgt_* ÁöÑÁª¥Â∫¶Ôºà‰∏çÁî®ÊîπÔºåËøôÈáåÊ≤øÁî®‰Ω†ÂéüÊù•ÁöÑ‰ª£Á†ÅÔºâ
    #         if tgt_boxes.shape != pred_boxes.shape:
    #             # ÊÉÖÂÜµ1Ôºötgt [B, A, H, W, 4] ‚Üí [B, H, W, A, 4]
    #             if tgt_boxes.shape[1] == self.num_anchors:
    #                 tgt_boxes = tgt_boxes.permute(0, 2, 3, 1, 4)
    #                 tgt_obj   = tgt_obj.permute(0, 2, 3, 1)
    #                 tgt_cls   = tgt_cls.permute(0, 2, 3, 1)
    #                 tgt_mask  = tgt_mask.permute(0, 2, 3, 1)
    #             # ÊÉÖÂÜµ2Ôºötgt [B, H, W, A, 4] but pred was [B, A, H, W, 4]
    #             elif tgt_boxes.shape[3] == self.num_anchors:
    #                 tgt_boxes = tgt_boxes.permute(0, 3, 1, 2, 4)
    #                 tgt_obj   = tgt_obj.permute(0, 3, 1, 2)
    #                 tgt_cls   = tgt_cls.permute(0, 3, 1, 2)
    #                 tgt_mask  = tgt_mask.permute(0, 3, 1, 2)

    #         # ‚Äî‚Äî 2.4 Êï∞ÂÄºÊ£ÄÊü•
    #         assert torch.all(pred_boxes.isfinite()) and torch.all(tgt_boxes.isfinite())
    #         assert torch.all((tgt_mask == 0) | (tgt_mask == 1))

    #         print(f"After alignment:")
    #         print(f"pred_boxes: {pred_boxes.shape}, tgt_boxes: {tgt_boxes.shape}")
    #         print(f"pred_obj: {pred_obj.shape},   tgt_obj: {tgt_obj.shape}")
    #         print(f"tgt_mask: {tgt_mask.shape}, sum: {tgt_mask.sum().item()}")

    #         # one-hot ‚Üí Á¥¢Âºï
    #         if tgt_cls.dim() == 5 and tgt_cls.shape[-1] == self.num_classes:
    #             tgt_cls = tgt_cls.argmax(dim=-1)

    #         # ‚Äî‚Äî 2.5 coord loss
    #         valid_count = tgt_mask.sum()
    #         if valid_count > 0:
    #             coord_loss = (self.mse_loss(pred_boxes, tgt_boxes) * tgt_mask.unsqueeze(-1)).sum() / valid_count
    #         else:
    #             coord_loss = torch.tensor(0., device=pred.device, requires_grad=True)

    #         # ‚Äî‚Äî 2.6 obj / noobj loss
    #         obj_loss   = (self.bce_loss(pred_obj, tgt_obj) * tgt_mask).sum() / max(1, tgt_mask.sum())
    #         noobj_loss = (self.bce_loss(pred_obj, tgt_obj) * (1 - tgt_mask)).sum() / max(1, (1 - tgt_mask).sum())

    #         # ‚Äî‚Äî 2.7 cls loss
    #         valid_pos = tgt_mask.bool()
    #         if valid_pos.sum() > 0:
    #             pred_cls_valid = pred_cls[valid_pos]            # [N_pos, C]
    #             tgt_cls_valid  = tgt_cls[valid_pos].long()      # [N_pos]
    #             print(">>> cls label range:", tgt_cls_valid.min().item(), "~", tgt_cls_valid.max().item())
    #             cls_loss = self.ce_loss(pred_cls_valid, tgt_cls_valid).mean()
    #         else:
    #             print(">>> ÂΩìÂâç batch Êó†ÊúâÊïàÁõÆÊ†áÁ±ªÂà´")
    #             cls_loss = torch.tensor(0., device=pred.device, requires_grad=True)

    #         # ‚Äî‚Äî 2.8 Âä†ÊùÉÊ±ÇÂíå & ËÆ∞ÂΩï
    #         loss = (self.lambda_coord * coord_loss + obj_loss
    #                 + self.lambda_noobj * noobj_loss + cls_loss)
    #         total_loss += loss

    #         with torch.no_grad():
    #             loss_dict['coord_loss'] += coord_loss.item()
    #             loss_dict['obj_loss']   += obj_loss.item()
    #             loss_dict['noobj_loss'] += noobj_loss.item()
    #             loss_dict['cls_loss']   += cls_loss.item()

    #     loss_dict['total_loss'] = total_loss.item()
    #     return total_loss, loss_dict

    def forward(self, predictions, targets):
        """
        predictions: Ê®°ÂûãËæìÂá∫ÂàóË°® [small, medium, large]
        targets: ÁúüÂÆûÊ†áÁ≠æÂ≠óÂÖ∏ÂàóË°®ÔºåÊØè‰∏™ÂÖÉÁ¥†ÂØπÂ∫î‰∏Ä‰∏™Â∞∫Â∫¶
        """
        total_loss = 0
        loss_dict = {'coord_loss': 0, 'obj_loss': 0, 'noobj_loss': 0, 'cls_loss': 0}
        
        for i, pred in enumerate(predictions):
            # Ëé∑ÂèñÂΩìÂâçÂ∞∫Â∫¶ÁöÑanchor
            anchor = self.anchors[i]
            
            print("Targets type:", type(targets))
            print("Targets length:", len(targets))

            # ÂÖ≥ÈîÆ‰øÆÊîπÔºö‰ΩøÁî®ÂØπÂ∫îÂ∞∫Â∫¶ÁöÑÁõÆÊ†áÔºåËÄå‰∏çÊòØÊÄªÊòØ‰ΩøÁî® targets[0]
            target = targets[i]  # Êîπ‰∏∫ targets[i] ËÄå‰∏çÊòØ targets[0]
            tgt_boxes = target['boxes']      # ÊúüÊúõ: [B, A, H, W, 4] 
            tgt_obj = target['conf']         # ÊúüÊúõ: [B, A, H, W]
            tgt_cls = target['classes']      # ÊúüÊúõ: [B, A, H, W]
            tgt_mask = target['mask']        # ÊúüÊúõ: [B, A, H, W]
            
            # Ë∞ÉËØï‰ø°ÊÅØ
            # print(f"Scale {i}:")
            # print(f"pred shape: {pred.shape}")
            # print(f"tgt_boxes shape: {tgt_boxes.shape}")
            # print(f"tgt_mask shape: {tgt_mask.shape}")
            
            # È¢ÑÊµãÂº†ÈáèÂ∫îËØ•ÊòØ [B, A, H, W, 85]ÔºåÂàÜÁ¶ª‰∏çÂêåÈÉ®ÂàÜ
            pred_boxes = pred[..., :4]      # [B, A, H, W, 4]
            pred_obj = pred[..., 4]         # [B, A, H, W]
            pred_cls = pred[..., 5:]        # [B, A, H, W, num_classes]
            
            # üî• ÂÖ≥ÈîÆ‰øÆÊîπÔºöÁ°Æ‰øùÁª¥Â∫¶‰∏ÄËá¥ÊÄßÊ£ÄÊü•
            # print(f"After extraction:")
            # print(f"pred_boxes shape: {pred_boxes.shape}")
            # print(f"tgt_boxes shape: {tgt_boxes.shape}")
            # print(f"tgt_mask shape: {tgt_mask.shape}")
            
            # È™åËØÅÁª¥Â∫¶ÊòØÂê¶ÂåπÈÖç
            if pred_boxes.shape != tgt_boxes.shape:
                raise ValueError(f"Â∞∫Â∫¶{i}Áª¥Â∫¶‰∏çÂåπÈÖç: pred={pred_boxes.shape} vs tgt={tgt_boxes.shape}")
            
            # ËÆ°ÁÆóÂùêÊ†áÊçüÂ§± (Âè™ÂØπÊúâÁâ©‰ΩìÁöÑ‰ΩçÁΩÆ)
            coord_loss = self.mse_loss(pred_boxes, tgt_boxes) * tgt_mask.unsqueeze(-1)
            coord_loss = coord_loss.sum() / max(1, tgt_mask.sum())
            
            # ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶ÊçüÂ§±
            obj_loss = self.bce_loss(pred_obj, tgt_obj) * tgt_mask
            noobj_loss = self.bce_loss(pred_obj, tgt_obj) * (1 - tgt_mask)
            
            obj_loss = obj_loss.sum() / max(1, tgt_mask.sum())
            noobj_loss = noobj_loss.sum() / max(1, (1 - tgt_mask).sum())
            
            # ËÆ°ÁÆóÂàÜÁ±ªÊçüÂ§± (Âè™ÂØπÊúâÁâ©‰ΩìÁöÑ‰ΩçÁΩÆ)
            valid_positions = tgt_mask.bool()
            if valid_positions.sum() > 0:
                pred_cls_valid = pred_cls[valid_positions]  # [num_valid_targets, num_classes]
                tgt_cls_valid = tgt_cls[valid_positions].long()  # [num_valid_targets]
                cls_loss = self.ce_loss(pred_cls_valid, tgt_cls_valid).mean()
            else:
                cls_loss = torch.tensor(0.0, device=pred.device, requires_grad=True)
            
            # Âä†ÊùÉÊÄªÊçüÂ§±
            scale_loss = (self.lambda_coord * coord_loss + 
                        obj_loss + 
                        self.lambda_noobj * noobj_loss + 
                        cls_loss)
            
            total_loss += scale_loss
            
            # ËÆ∞ÂΩïÂêÑÈ°πÊçüÂ§±
            loss_dict['coord_loss'] += coord_loss.item()
            loss_dict['obj_loss'] += obj_loss.item()
            loss_dict['noobj_loss'] += noobj_loss.item()
            loss_dict['cls_loss'] += cls_loss.item()
        
        loss_dict['total_loss'] = total_loss.item()
        return total_loss, loss_dict 


        
    # def forward(self, predictions, targets):
    #     """
    #     predictions: Ê®°ÂûãËæìÂá∫ÂàóË°® [small, medium, large]
    #     targets: ÁúüÂÆûÊ†áÁ≠æÂ≠óÂÖ∏ÂàóË°®ÔºåÊØè‰∏™ÂÖÉÁ¥†ÂØπÂ∫î‰∏Ä‰∏™Â∞∫Â∫¶
    #     """
    #     # ÂÖºÂÆπ dict ËæìÂÖ•
    #     if isinstance(targets, dict):
    #         # ÂÅáËÆæÂè™Êúâ‰∏Ä‰∏™Â∞∫Â∫¶
    #         targets = [targets]
    #     # ÂÖºÂÆπ {0: {...}} ËøôÁßçÊÉÖÂÜµ
    #     elif isinstance(targets, dict) and 0 in targets:
    #         targets = [targets[0]]
    #     total_loss = 0
    #     loss_dict = {'coord_loss': 0, 'obj_loss': 0, 'noobj_loss': 0, 'cls_loss': 0}
        
    #     for i, pred in enumerate(predictions):
    #         # Ëé∑ÂèñÂΩìÂâçÂ∞∫Â∫¶ÁöÑanchor
    #         anchor = self.anchors[i]
            
    #         # ÂàÜÁ¶ªÈ¢ÑÊµãÁöÑ‰∏çÂêåÈÉ®ÂàÜ
    #         pred_boxes = pred[..., :4]      # ËæπÁïåÊ°ÜÂùêÊ†á (tx, ty, tw, th)
    #         pred_obj = pred[..., 4]        # ÁΩÆ‰ø°Â∫¶
    #         pred_cls = pred[..., 5:]       # Á±ªÂà´Ê¶ÇÁéá
            

    #         # Ê∑ªÂä†Ë∞ÉËØï‰ª£Á†Å
    #         #print("targets keys:", targets.keys())
    #         print("targets type:", type(targets))
    #         print("targets content:", targets)


    #         # Ëé∑ÂèñÁõÆÊ†áÂÄº
    #         target = targets[i]
    #         tgt_boxes = target['boxes']
    #         tgt_obj = target['conf']
    #         tgt_cls = target['classes']
    #         tgt_mask = target['mask']      # ÊåáÁ§∫Âì™‰∫õ‰ΩçÁΩÆÊúâÁâ©‰Ωì
    #         # ÊâìÂç∞shapeË∞ÉËØï
    #         if pred_boxes.shape != tgt_boxes.shape:
    #             print("Before permute, pred_boxes shape:", pred_boxes.shape)
    #             tgt_boxes = tgt_boxes.permute(0, 3, 1, 2, 4)  # [B, A, H, W, 4] -> [B, H, W, A, 4]
    #             print("After permute, tgt_boxes shape:", tgt_boxes.shape)
    #         # ËÆ°ÁÆóÂùêÊ†áÊçüÂ§± (Âè™ÂØπÊúâÁâ©‰ΩìÁöÑ‰ΩçÁΩÆ)
    #         coord_loss = self.mse_loss(pred_boxes, tgt_boxes) * tgt_mask.unsqueeze(-1)
    #         coord_loss = coord_loss.sum() / max(1, tgt_mask.sum())
            
    #         # ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶ÊçüÂ§±
    #         obj_loss = self.bce_loss(pred_obj, tgt_obj) * tgt_mask
    #         noobj_loss = self.bce_loss(pred_obj, tgt_obj) * (1 - tgt_mask)
            
    #         obj_loss = obj_loss.sum() / max(1, tgt_mask.sum())
    #         noobj_loss = noobj_loss.sum() / max(1, (1 - tgt_mask).sum())
            
    #         # ËÆ°ÁÆóÂàÜÁ±ªÊçüÂ§± (Âè™ÂØπÊúâÁâ©‰ΩìÁöÑ‰ΩçÁΩÆ)
    #         cls_loss = self.ce_loss(
    #             pred_cls.view(-1, self.num_classes),
    #             tgt_cls.view(-1).long()
    #         ) * tgt_mask.view(-1)
    #         cls_loss = cls_loss.sum() / max(1, tgt_mask.sum())
            
    #         # Âä†ÊùÉÊÄªÊçüÂ§±
    #         scale_loss = (self.lambda_coord * coord_loss + 
    #                      obj_loss + 
    #                      self.lambda_noobj * noobj_loss + 
    #                      cls_loss)
            
    #         total_loss += scale_loss
            
    #         # ËÆ∞ÂΩïÂêÑÈ°πÊçüÂ§±
    #         loss_dict['coord_loss'] += coord_loss.item()
    #         loss_dict['obj_loss'] += obj_loss.item()
    #         loss_dict['noobj_loss'] += noobj_loss.item()
    #         loss_dict['cls_loss'] += cls_loss.item()
        
    #     loss_dict['total_loss'] = total_loss.item()
    #     return total_loss, loss_dict

def reweight_loss(loss, labels, class_weights):
    """
    ÊçüÂ§±ÈáçÂä†ÊùÉÔºöÊ†πÊçÆÁ±ªÂà´ÊùÉÈáçË∞ÉÊï¥loss„ÄÇ
    loss: [N]Ôºålabels: [N]Ôºåclass_weights: dict or tensor
    """
    # TODO: ÊåâlabelsÊü•Êâæclass_weightsÔºå‰πò‰ª•loss
    # Á§∫‰æãÔºöloss = loss * class_weights[labels]
    return loss